import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt

class NeuralNetwork(nn.Module):
    def __init__(self, input_dim, hidden1, hidden2, output_dim):
        super(NeuralNetwork, self).__init__()
        self.layer1 = nn.Linear(input_dim, hidden1)
        self.layer2 = nn.Linear(hidden1, hidden2)
        self.layer3 = nn.Linear(hidden2, output_dim)
        self.layer1.reset_parameters()
        self.layer2.reset_parameters()
        self.layer3.reset_parameters()

    def forward(self, x):
        x = torch.sigmoid(self.layer1(x))
        x = torch.sigmoid(self.layer2(x))
        x = self.layer3(x)
        return torch.softmax(x.view(-1, 9), dim=1).view(-1, 81, 9)  # Reshape to (batch_size, 81, 9)

def one_hot_encode(grid):
    """Convert numbers 1-9 into one-hot vectors; 0s are left as all-zero vectors."""
    identity = np.eye(9)
    encoded = np.array([identity[int(x)-1] if x != 0 else np.zeros(9) for x in grid.flatten()])
    return encoded.reshape(-1)

def one_hot_decode(grid):
    """Convert one-hot encoded vectors back to numbers 1-9; all-zero vectors are converted to 0."""
    return np.argmax(grid, axis=1).reshape(9,9) + 1

# Generating a sample Sudoku puzzle (partially filled)
sample_grid = np.array([
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 7, 9]
])

# Solution for training (complete grid)
solution_grid = np.array([
    [5, 3, 4, 6, 7, 8, 9, 1, 2],
    [6, 7, 2, 1, 9, 5, 3, 4, 8],
    [1, 9, 8, 3, 4, 2, 5, 6, 7],
    [8, 5, 9, 7, 6, 1, 4, 2, 3],
    [4, 2, 6, 8, 5, 3, 7, 9, 1],
    [7, 1, 3, 9, 2, 4, 8, 5, 6],
    [9, 6, 1, 5, 3, 7, 2, 8, 4],
    [2, 8, 7, 4, 1, 9, 6, 3, 5],
    [3, 4, 5, 2, 8, 6, 1, 7, 9]
])

X_train = torch.tensor(one_hot_encode(sample_grid), dtype=torch.float32)
y_train = torch.tensor(one_hot_encode(solution_grid), dtype=torch.float32)

model = NeuralNetwork(81*9, 512, 512, 81*9)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training the model
epochs = 5000
for epoch in range(epochs):
    model.train()
    optimizer.zero_grad()
    outputs = model(X_train.unsqueeze(0))  # Add batch dimension
    loss = criterion(outputs.view(-1, 9), y_train.view(-1, 9).argmax(dim=1))
    loss.backward()
    optimizer.step()

    if (epoch + 1) % 100 == 0:
        print(f'Epoch {epoch + 1}, Loss: {loss.item():.4f}')

# Testing the model
model.eval()
with torch.no_grad():
    predictions = model(X_train.unsqueeze(0))
    predicted_digits = one_hot_decode(predictions.squeeze(0).detach().numpy())
    print("\nPredicted Sudoku Grid:")
    print(predicted_digits)

# Function to plot the Sudoku grid
def plot_sudoku(grid):
    fig, ax = plt.subplots(figsize=(5,5))
    ax.matshow(grid, cmap='viridis', alpha=0.8)
    for (i, j), val in np.ndenumerate(grid):
        ax.text(j, i, str(val), ha='center', va='center', color='white' if val != 0 else 'black')
    plt.xticks([])
    plt.yticks([])
    plt.show()

plot_sudoku(predicted_digits)
 
